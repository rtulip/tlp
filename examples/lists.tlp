use "std.tlp"

const StrStackCap 10 end
reserve StrStackData StrStackCap SizeOf(Str) * end
reserve StrStackPtr SizeOf(ptr) end
reserve StrStackSize SizeOf(int) end


with T
struct Stack 
    with T &fn ptr -> T ptr end // read
    with T &fn T ptr -> ptr end // write
    ptr   // ptr
    ptr   // size 
    int   // cap
end 

with T
fn Stack.Print
    with T -> Stack
do
    split
    "Capacity: " puts putu
    "Size: " puts @64 putu
    "Ptr: " puts @64 putu
    drop drop
end


with T
fn Stack.Init
    with T -> Stack
    ptr
do
    cast(int) push
    split drop
    0 swap !64
    pop swap !64

    drop drop
end

with T
fn Stack.Push
    with T -> Stack
    T
do
    push split

    push dup @64 pop 
    if < not do
        "Cannot push to stack. It's full.\n" eputs
        1 exit
    end 

    dup @64 1 + swap !64
    
    pop swap dup push @64 push push
    swap drop
    pop swap pop cast(ptr) swap call
    pop !64

end

with T
fn Stack.Pop
    with T -> Stack
    ->
    T
do
    split drop

     
    if dup @64 0 == do
        "Cannot pop from stack. It's empty.\n" eputs
        1 exit
    end 

    dup @64 1 - swap !64
    
    dup push @64 cast(ptr) push drop
    pop swap call 
    pop !64

end

fn write_str Str ptr -> ptr do
    push
    "Writing: `" puts dup puts "` to address " puts
    pop dup cast(int) putu
    !Str
    "Final Address: " puts dup cast(int) putu
end

fn read_str ptr -> Str ptr  do
    "Reading from address " puts dup cast(int) putu
    @Str
end

fn S 
    -> 
    with Str -> Stack
do
    &@Str
    &!Str
    StrStackPtr
    StrStackSize
    StrStackCap
    cast(Stack)
end


S StrStackData with Str do Stack.Init
0 while dup 10 < do
    S "Hello Stacks..."
    with Str do Stack.Push
    1 +
end drop

0 while dup 10 < do
    "Read: `" puts S with Str do Stack.Pop puts "`\n" puts
    1 +
end drop
