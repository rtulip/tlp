use "sys_x86_64_linux.tlp"
use "libs/str.tlp"

const SizeOf(int)  8 end
const SizeOf(bool) 8 end
const SizeOf(ptr)  8 end
const SizeOf(Str)  SizeOf(int) SizeOf(ptr) + end

const PUTD_BUFFER_SIZE 20 end
reserve putd_buffer PUTD_BUFFER_SIZE end

const STATBUF_CAP 144 end
const STATBUF_SIZE_OFFSET 48 end
const FILE_BUFFER_CAP 1000000 end

reserve statbuf STATBUF_CAP end
fn statbuf.size ptr -> int do
    cast(int) STATBUF_SIZE_OFFSET + cast(ptr) @64
end

reserve file_buffer FILE_BUFFER_CAP end


// File permissions
const O_RDONLY    0       end 
const O_WRONLY    1       end
const O_RDWR      1 1 <<  end
const O_CREAT     1 6 <<  end
const O_EXCL      1 7 <<  end
const O_NOCTTY    1 8 <<  end
const O_TRUNC     1 9 <<  end
const O_APPEND    1 10 << end
const O_DIRECOTRY 1 15 << end
const O_NOFOLLOW  1 17 << end
const O_CLOEXEC   1 19 << end

// Other user permission values
const S_IXOTH 1      end
const S_IWOTH 1 1 << end
const S_IROTH 1 2 << end
const S_IRWXO 
    S_IXOTH S_IWOTH S_IROTH or or
end

// Group permission values 

const S_IXGRP 1 3 << end
const S_IWGRP 1 4 << end
const S_IRGRP 1 5 << end
const S_IRWXG
    S_IXGRP S_IWGRP S_IRGRP or or
end

// User permission values
const S_IXUSR 1 6 << end
const S_IWUSR 1 7 << end
const S_IRUSR 1 8 << end
const S_IRWXU
    S_IRUSR S_IWUSR S_IXUSR or or
end

const S_ISVTX 1 9  << end
const S_ISUID 1 10 << end
const S_ISGID 1 11 << end

fn stdout -> FileDesc do
    1 cast(FileDesc)
end

fn exit int do
    sys_exit
end

// Prints a string to stderr.
// No error handling is done here.
fn eputs Str do
    
    split 2 cast(FileDesc) sys_write drop drop
end     

// Prints a String to stdout.
// Error messages put to stderr.
fn puts Str do
    // dup Str.Size putu
    dup split 1 cast(FileDesc)
    
    if sys_write swap drop do
        drop    // Str
    else
        "Failed to write to stdout:\n" eputs
        "Tried to write: `" eputs eputs "`\n" eputs
        1 exit
    end
end

fn putb bool do
    if do
        "True\n" puts
    else
        "False\n" puts
    end
end

// Prints a String to a file.
// Error handling message is put to stderr
fn fputs 
    FileDesc Str
    -> 
    FileDesc
do 
    2 group dup
    dup group.1 Str.Size swap
    dup group.1 Str.Data swap
    group.0
    
    if sys_write swap drop do else
        "Failed to write to file:\n" eputs
        "\t[Text]: " eputs 
        dup group.1 eputs
        1 exit
    end

    group.0

end

fn fputd FileDesc int -> FileDesc do

    if dup 0 == do
        drop "0" puts 
    else
    
        putd_buffer cast(int) PUTD_BUFFER_SIZE 1 - + cast(ptr) swap

        // ptr int 
        while dup 0 > do

            2 group dup split

            // ptr int
            10 % 48 + swap !8
            
            split
            10 / swap
            cast(int) 1 - cast(ptr) swap

        end drop

        cast(int) 1 +

        dup putd_buffer cast(int) PUTD_BUFFER_SIZE + swap -
        swap cast(ptr)
        cast(Str) fputs

    end
end

fn putd int do

    stdout swap fputd drop

end

fn fopen
    int int Str // Mode Flags Filename
    ->
    FileDesc
do
    // Save the filename on the stack before the Mode
    3 group dup group.2 swap split

    // Extract just the pointer to the data from Str
    Str.Data 
    
    if sys_open do
        // Drop the String as it's not needed for error handling
        swap drop
    else 
        "Failed to open file: `" eputs
        swap eputs
        "`\n" eputs

        1 exit
    end
end

fn fclose FileDesc do
    if sys_close do else 
        "Failed to close file\n" eputs
        1 exit
    end
end

fn stat ptr Str do
    Str.Data
    if sys_stat do else 
        "Stat failed\n" eputs
    end
end

fn load_file_to_str Str -> Str do
    dup 
    statbuf swap stat

    if statbuf statbuf.size FILE_BUFFER_CAP > do 
        "File too big to read.\n" eputs
        1 exit
    end

    O_RDONLY swap 0 swap fopen dup
    statbuf statbuf.size swap
    file_buffer swap
    
    if sys_read do
        drop
        fclose
    else
        "Failed to read from file\n" eputs
        drop
        fclose 
        1 exit
    end
    
    statbuf statbuf.size file_buffer cast(Str)

end 

struct pair
    int int 
end

struct temp
    pair int 
end

fn mul int int -> int do 
    cast(pair) 0 cast(temp)
    // T[ P[a b] r] 
    while dup temp.0 pair.1 0 > do
        // P[a (b-1)] (r+a) 
        dup split swap pair.0 + swap
        temp.0 split 1 - cast(pair) swap cast(temp)
    end
    temp.1
end

fn exp int int -> int do
    cast(pair) 1 cast(temp)
    // T[ P[a b] r] 
    while dup temp.0 pair.1 0 > do
        // P[a (b-1)] (r+a) 
        dup split swap pair.0 mul swap
        temp.0 split 1 - cast(pair) swap cast(temp)
    end
    temp.1

end

fn not bool -> bool do
    if do
        false
    else 
        true
    end
end

fn Str.ToInt Str -> int do 
    if dup Str.Numeric do 
        0 swap
        while dup Str.Size 0 > do 

            // (10^(Str.Size - 1)*int(Str[0]))+result Str 
            2 group dup dup dup
            group.1 Str.Size 1 - 10 swap exp swap
            group.1 0 Str.At ASCII_0 - mul swap
            group.0 + swap
            group.1 1 Str.ShiftRightBy

        end drop
        
    else 
        eputs "is not numeric!\n" eputs
        1 exit
        0
    end

end