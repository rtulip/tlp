use "std.tlp"
use "lexer.tlp"

const OpType.PUSH_UINT      0                       end
const OpType.PUSH_BOOL      OpType.PUSH_UINT 1 +    end
const OpType.PUSH_PTR       OpType.PUSH_BOOL 1 +    end
const OpType.PUSH_STRING    OpType.PUSH_PTR 1 +     end
const OpType.INTRINSIC      OpType.PUSH_STRING 1 +  end
const OpType.JUMP_COND      OpType.INTRINSIC 1 +    end
const OpType.JUMP           OpType.JUMP_COND 1 +    end
const OpType.RETURN         OpType.JUMP 1 +         end
const OpType.CALL           OpType.RETURN 1 +       end
const OpType.NOP            OpType.CALL 1 +         end

const SizeOf(Op) SizeOf(int) SizeOf(Token) SizeOf(TokenValue) + + end
struct Op
    int        // OpType
    Token      // token
    TokenValue // Operand
end

fn !Op Op ptr -> ptr do
    push split pop
    !TokenValue !Token !int
end

fn @Op ptr -> Op ptr do
    @int @Token @TokenValue
    push cast(Op) pop
end

const ProgramCap 10000 end
reserve ProgramData ProgramCap SizeOf(Op) * end
reserve ProgramSize SizeOf(int) end
reserve ProgramPtr  SizeOf(ptr) end

fn Program.Init do
    ProgramData ProgramPtr !64
    0 ProgramSize !64
end

fn Program.Push Op do
    ProgramPtr @64 cast(ptr) !Op ProgramPtr !64
    ProgramSize @64 1 + ProgramSize !64
end

fn Program.Pop -> Token do
    ProgramPtr @64 SizeOf(ptr) - cast(ptr)
    @Token ProgramPtr !64
    ProgramSize @64 1 - ProgramSize !64
end

fn Program.Index int -> Op do
    if dup ProgramSize @64 < do
        1 + SizeOf(Op) *
        ProgramData swap ptr_offset 
        cast(int) SizeOf(int) - cast(ptr)
        @Op drop
    else
        "[ERROR] Index " eputs eputd " is out of range for Program[]\n" eputs
        1 exit
        NULL @Op drop
    end
end

fn main do 

    "tlp.tlp" tokenize_file
    Tokens.Reverse

    while Tokens.Size 0 > do 
        Tokens.Pop Token.Print
    end

end

main